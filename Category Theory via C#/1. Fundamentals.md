ORIGIN: https://weblogs.asp.net/dixin/category-theory-via-csharp-1-fundamentals

# Теория категорий с языком C# (1) Основы
<p>
    Теория категорий - это теоретический фреймворк для описания абстрактных структур и отношений в математике. Термин был введен [Самуэлем Эйленбергом](https://ru.wikipedia.org/wiki/%D0%AD%D0%B9%D0%BB%D0%B5%D0%BD%D0%B1%D0%B5%D1%80%D0%B3,_%D0%A1%D0%B0%D0%BC%D1%83%D1%8D%D0%BB%D1%8C) и [Саундерсом Маклейном](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D0%BB%D0%B5%D0%B9%D0%BD,_%D0%A1%D0%B0%D1%83%D0%BD%D0%B4%D0%B5%D1%80%D1%81) в 1940-х годах. Этот раздел рассматривает математические концепты и свойства абстрактно, сводя их к совокупности предметов и отношений между ними. Теория категорий абстрактна, и [Норман Стинрод](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B8%D0%BD%D1%80%D0%BE%D0%B4,_%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BD) назвал её "[general abstract nonsense](https://en.wikipedia.org/wiki/Abstract_nonsense)"; она находит применение в многих областях математики, физики, комьютерных наук и т.д. Для программирования теория категорий - это алгебраическая теория типов и функций. Она находится в основе LINQ и всех функциональных языков. В этой серии статей мы рассмотрим важные понятия, такие как категория, морфизм, естественное преобразование, моноид, функтор, монада и другие. Эти ключевые абстрактные понятия будут проилюстрированны с помощью интуитивно понятных диаграмм и примеров на C# и LINQ. Эти знания из теории категорий помогут глубже понять функциональное программирование на C# или других языках, так как любой язык с типами и функциями является _категорико-теоретической структурой_.
<p>

## Категория и законы категории
В теории категорий, категоря C - это алгебраическая структура, состоящая из 3 типов математических сущностей :
* Множества объектов, обозначается ob(C). Это не те же самые объекты из [ООП](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).
* Множество морфизмов (отношений или стрелок/соответствий) между объектами, обозначается hom(C). Морфизм *m* для преобразования исходного объекта *X* в объект *Y* обозначается как _m: X → Y_
* Операции композиции для морфизмов, обозначаются ∘. Для морфизмов _m1: X → Y_ и _m2: Y → Z_ композиция также является морфизмом (m2 ∘ m1): X → Z. m2 ∘ m1 можно читать как преобразование m2 после m1
![picture](https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/Category-Theory-via-C-1-Fundamentals_6A3A/image_thumb.png)

Эти сущности должны удовлетворять 2 законам категорий:
* Ассоциативный(сочетательный) закон: композиция морфизмов должна быть [ассоциативной](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F): для m1: W → X, m2: X → Y и m3: Y → Z, выполняется равенство (m3 ∘ m2) ∘ m1≡ ≡ m3 ∘ (m2 ∘ m1).
* Закон тождества: для каждого объекта Х существует тождественное преобразование(морфизм/отображение):  idx : X → X, тождественное преобразование является нейтральным по отношению к композиции. Для m: X → Y, выполняется idY ∘ m ≡ m ≡ m ∘ idX.

![picture](https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/Category-Theory-via-C-1-Fundamentals_6A3A/image_thumb_3.png)

Чтобы сделать эти абстрактные определения понятней и наглядней, можно представить их в виде интерфейса:


```csharp
public interface ICategory<TObject, TMorphism>
{
    IEnumerable<TObject> Objects { get; }

    TMorphism Compose(TMorphism morphism2, TMorphism morphism1);

    TMorphism Id(TObject @object);
}
```
Простым примером категории может послужить категория целых чисел (integers), где множеством объектов являются все целые числа, а за множество морфизмов можно взять отношения ≤ (меньше или равно), между числом и самим собой, или же между числом и другим числом, большим или равным ему. Например: m1: 0 → 1 (0 ≤ 1), m2: 1 → 10 (1 ≤ 10), и так далее.
?Что касается транзитивности неравенства?, то ≤ морфизмы можно объединять, например морфизм m1: 0 → 1 (0 ≤ 1) и морфизм m2: 1 → 10 (1 ≤ 10) можно "склеить" в морфизм (m2 ∘ m1): 0 → 10 (0 ≤ 10).
![picture](https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/248e0c9c0941_E1F4/image_thumb.png)
